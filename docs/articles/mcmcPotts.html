<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>mcmcPotts • bayesImageS</title>
<!-- jquery --><script src="https://code.jquery.com/jquery-3.1.0.min.js" integrity="sha384-nrOSfDHtoPMzJHjVTdCopGqIqeYETSXhZDFyniQ8ZHcVy08QesyHcnOUpMpqnmWq" crossorigin="anonymous"></script><!-- Bootstrap --><link href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous">
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"></script><!-- Font Awesome icons --><link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" integrity="sha384-T8Gy5hrqNKT+hzMclPo118YTQO6cYprQmhrYwIiQ/3axmI1hQomh7Ud2hPOy8SP1" crossorigin="anonymous">
<!-- pkgdown --><link href="../pkgdown.css" rel="stylesheet">
<script src="../jquery.sticky-kit.min.js"></script><script src="../pkgdown.js"></script><!-- mathjax --><script src="https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><!--[if lt IE 9]>
<script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
<script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
<![endif]-->
</head>
<body>
    <div class="container template-vignette">
      <header><div class="navbar navbar-default navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="../index.html">bayesImageS</a>
    </div>
    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
<li>
  <a href="../index.html">
    <span class="fa fa-home fa-lg"></span>
     
  </a>
</li>
<li>
  <a href="../reference/index.html">Reference</a>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">
    Articles
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
<li>
      <a href="../articles/mcmcPotts.html">mcmcPotts</a>
    </li>
    <li>
      <a href="../articles/mcmcPottsNoData.html">mcmcPottsNoData</a>
    </li>
    <li>
      <a href="../articles/PFAB.html">PFAB algorithm</a>
    </li>
    <li>
      <a href="../articles/swNoData.html">swNoData</a>
    </li>
  </ul>
</li>
<li>
  <a href="../news/index.html">News</a>
</li>
      </ul>
<ul class="nav navbar-nav navbar-right"></ul>
</div>
<!--/.nav-collapse -->
  </div>
<!--/.container -->
</div>
<!--/.navbar -->

      
      </header><div class="row">
  <div class="col-md-9">
    <div class="page-header toc-ignore">
      <h1>mcmcPotts</h1>
                        <h4 class="author">Matt Moores</h4>
            
            <h4 class="date">19 November 2017</h4>
          </div>

    
    
<div class="contents">
<p>This post looks at the convergence of the chequerboard Gibbs sampler for the hidden Potts model, in the presence of an external field. This algorithm is implemented as the function <a href="https://mooresm.github.io/bayesImageS/reference/mcmcPotts.html"><code>mcmcPotts</code></a> in my R package, <a href="https://CRAN.R-project.org/package=bayesImageS"><strong>bayesImageS</strong></a>. Previous posts have looked at the convergence of Gibbs and Swendsen-Wang algorithms without an external field, as implemented in <a href="https://mattstats.wordpress.com/2017/01/17/bayesimagesmcmcpottsnodata/"><code>mcmcPottsNoData</code></a> and <a href="https://mattstats.wordpress.com/2013/12/13/swnodata/"><code>swNoData</code></a> functions.</p>
<hr>
<p>The most accurate way to measure convergence is using the coupling time of a perfect sampling algorithm, such as <a href="">coupling from the past</a> (CFTP). However, we can obtain a rough estimate by monitoring the distribution of the sufficient statistic: <span class="math display">\[
\text{S}(\mathbf{z}) = \sum_{\{i,j\} \in \mathcal{E}} \delta(z_i, z_j)
\]</span> Where <span class="math inline">\(\delta(x,y)\)</span> is the <a href="https://en.wikipedia.org/wiki/Kronecker_delta">Kronecker delta</a> function. Note that this sum is defined over the <em>unique</em> undirected edges of the lattice, to avoid double-counting. Under this definition, the critical temperature of the <span class="math inline">\(q\)</span>-state Potts model is <span class="math inline">\(\log\{1 + \sqrt{q}\}\)</span>, or <span class="math inline">\(\approx 0.88\)</span> for the Ising model with <span class="math inline">\(q=2\)</span> unique labels. Some papers state that the critical temperature of the Ising model is <span class="math inline">\(0.44\)</span>, but this is because they have used a different definition of <span class="math inline">\(\text{S}(\mathbf{z})\)</span>.</p>
<p>We will generate synthetic data for a sequence of values of the inverse temperature, <span class="math inline">\(\beta = (0.22, 0.44, 0.88, 1.32)\)</span>:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(bayesImageS)
<span class="kw">library</span>(doParallel)</code></pre></div>
<pre><code>## Loading required package: foreach</code></pre>
<pre><code>## Loading required package: iterators</code></pre>
<pre><code>## Loading required package: parallel</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">set.seed</span>(<span class="dv">123</span>)
q &lt;-<span class="st"> </span><span class="dv">2</span>
beta &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="fl">0.22</span>, <span class="fl">0.44</span>, <span class="fl">0.88</span>, <span class="fl">1.32</span>)
mask &lt;-<span class="st"> </span><span class="kw">matrix</span>(<span class="dv">1</span>,<span class="dt">nrow=</span><span class="dv">500</span>,<span class="dt">ncol=</span><span class="dv">500</span>)
n &lt;-<span class="st"> </span><span class="kw">prod</span>(<span class="kw">dim</span>(mask))
neigh &lt;-<span class="st"> </span><span class="kw"><a href="../reference/getNeighbors.html">getNeighbors</a></span>(mask, <span class="kw">c</span>(<span class="dv">2</span>,<span class="dv">2</span>,<span class="dv">0</span>,<span class="dv">0</span>))
block &lt;-<span class="st"> </span><span class="kw"><a href="../reference/getBlocks.html">getBlocks</a></span>(mask, <span class="dv">2</span>)
edges &lt;-<span class="st"> </span><span class="kw"><a href="../reference/getEdges.html">getEdges</a></span>(mask, <span class="kw">c</span>(<span class="dv">2</span>,<span class="dv">2</span>,<span class="dv">0</span>,<span class="dv">0</span>))
maxS &lt;-<span class="st"> </span><span class="kw">nrow</span>(edges)

cl &lt;-<span class="st"> </span><span class="kw">makeCluster</span>(<span class="kw">min</span>(<span class="dv">4</span>, <span class="kw">detectCores</span>()))
<span class="kw"><a href="http://www.rdocumentation.org/packages/doParallel/topics/registerDoParallel">registerDoParallel</a></span>(cl)

<span class="kw">system.time</span>(synth &lt;-<span class="st"> </span><span class="kw">foreach</span> (<span class="dt">i=</span><span class="dv">1</span><span class="op">:</span><span class="kw">length</span>(beta),
                      <span class="dt">.packages=</span><span class="st">"bayesImageS"</span>) <span class="op">%dopar%</span><span class="st"> </span>{
  gen &lt;-<span class="st"> </span><span class="kw">list</span>()
  gen<span class="op">$</span>beta &lt;-<span class="st"> </span>beta[i]
  <span class="co"># generate labels</span>
  sw &lt;-<span class="st"> </span><span class="kw"><a href="../reference/swNoData.html">swNoData</a></span>(beta[i], q, neigh, block, <span class="dv">200</span>)
  gen<span class="op">$</span>z &lt;-<span class="st"> </span>sw<span class="op">$</span>z
  gen<span class="op">$</span>sum &lt;-<span class="st"> </span>sw<span class="op">$</span>sum[<span class="dv">200</span>]
  <span class="co"># now add noise</span>
  gen<span class="op">$</span>mu &lt;-<span class="st"> </span><span class="kw">rnorm</span>(<span class="dv">2</span>, <span class="kw">c</span>(<span class="op">-</span><span class="dv">1</span>,<span class="dv">1</span>), <span class="fl">0.5</span>)
  gen<span class="op">$</span>sd &lt;-<span class="st"> </span><span class="dv">1</span><span class="op">/</span><span class="kw">sqrt</span>(<span class="kw">rgamma</span>(<span class="dv">2</span>, <span class="fl">1.5</span>, <span class="dv">2</span>))
  gen<span class="op">$</span>y &lt;-<span class="st"> </span><span class="kw">rnorm</span>(n, gen<span class="op">$</span>mu[(gen<span class="op">$</span>z[<span class="dv">1</span><span class="op">:</span>n,<span class="dv">1</span>])<span class="op">+</span><span class="dv">1</span>],
                    gen<span class="op">$</span>sd[(gen<span class="op">$</span>z[<span class="dv">1</span><span class="op">:</span>n,<span class="dv">1</span>])<span class="op">+</span><span class="dv">1</span>])
  gen
})</code></pre></div>
<pre><code>##    user  system elapsed 
##   0.285   0.045  12.477</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">stopCluster</span>(cl)</code></pre></div>
<p>Now let’s look at the distribution of Gibbs samples for the first dataset, using a fixed value of <span class="math inline">\(\beta\)</span>:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">priors &lt;-<span class="st"> </span><span class="kw">list</span>()
priors<span class="op">$</span>k &lt;-<span class="st"> </span>q
priors<span class="op">$</span>mu &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="op">-</span><span class="dv">1</span>,<span class="dv">1</span>)
priors<span class="op">$</span>mu.sd &lt;-<span class="st"> </span><span class="kw">rep</span>(<span class="fl">0.5</span>,q)
priors<span class="op">$</span>sigma &lt;-<span class="st"> </span><span class="kw">rep</span>(<span class="dv">2</span>,q)
priors<span class="op">$</span>sigma.nu &lt;-<span class="st"> </span><span class="kw">rep</span>(<span class="fl">1.5</span>,q)
priors<span class="op">$</span>beta &lt;-<span class="st"> </span><span class="kw">rep</span>(synth[[<span class="dv">1</span>]]<span class="op">$</span>beta, <span class="dv">2</span>)

mh &lt;-<span class="st"> </span><span class="kw">list</span>(<span class="dt">algorithm=</span><span class="st">"ex"</span>, <span class="dt">bandwidth=</span><span class="dv">1</span>, <span class="dt">adaptive=</span><span class="ot">NA</span>,
           <span class="dt">auxiliary=</span><span class="dv">1</span>)
tm &lt;-<span class="st"> </span><span class="kw">system.time</span>(res &lt;-<span class="st"> </span><span class="kw"><a href="../reference/mcmcPotts.html">mcmcPotts</a></span>(synth[[<span class="dv">1</span>]]<span class="op">$</span>y, neigh,
                            block, priors, mh, <span class="dv">100</span>, <span class="dv">50</span>))</code></pre></div>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">print</span>(tm)</code></pre></div>
<pre><code>##    user  system elapsed 
##  33.009   1.030   8.778</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">mean</span>(res<span class="op">$</span>sum[<span class="dv">51</span><span class="op">:</span><span class="dv">100</span>])</code></pre></div>
<pre><code>## [1] 277476.6</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">print</span>(synth[[<span class="dv">1</span>]]<span class="op">$</span>sum)</code></pre></div>
<pre><code>## [1] 277689</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">ts.plot</span>(res<span class="op">$</span>sum, <span class="dt">xlab=</span><span class="st">"MCMC iterations"</span>, <span class="dt">ylab=</span><span class="kw">expression</span>(<span class="kw">S</span>(z)))
<span class="kw">abline</span>(<span class="dt">h=</span>synth[[<span class="dv">1</span>]]<span class="op">$</span>sum, <span class="dt">col=</span><span class="dv">4</span>, <span class="dt">lty=</span><span class="dv">2</span>)</code></pre></div>
<p><img src="mcmcPotts_files/figure-html/unnamed-chunk-3-1.png" width="672"></p>
<p>As expected for <span class="math inline">\(\beta=0.22\)</span> with <span class="math inline">\(n=400\)</span> pixels, convergence takes only a dozen iterations or so. The same is true for <span class="math inline">\(\beta=0.66\)</span>:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">priors<span class="op">$</span>beta &lt;-<span class="st"> </span><span class="kw">rep</span>(synth[[<span class="dv">2</span>]]<span class="op">$</span>beta, <span class="dv">2</span>)
tm2 &lt;-<span class="st"> </span><span class="kw">system.time</span>(res2 &lt;-<span class="st"> </span><span class="kw"><a href="../reference/mcmcPotts.html">mcmcPotts</a></span>(synth[[<span class="dv">2</span>]]<span class="op">$</span>y,
                      neigh, block, priors, mh, <span class="dv">100</span>, <span class="dv">50</span>))</code></pre></div>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">print</span>(tm2)</code></pre></div>
<pre><code>##    user  system elapsed 
##  32.898   1.563   9.367</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">ts.plot</span>(res2<span class="op">$</span>sum, <span class="dt">xlab=</span><span class="st">"MCMC iterations"</span>, <span class="dt">ylab=</span><span class="kw">expression</span>(<span class="kw">S</span>(z)))
<span class="kw">abline</span>(<span class="dt">h=</span>synth[[<span class="dv">2</span>]]<span class="op">$</span>sum, <span class="dt">col=</span><span class="dv">4</span>, <span class="dt">lty=</span><span class="dv">2</span>)</code></pre></div>
<p><img src="mcmcPotts_files/figure-html/unnamed-chunk-5-1.png" width="672"></p>
<p>Now with <span class="math inline">\(\beta=0.88\)</span>:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">priors<span class="op">$</span>beta &lt;-<span class="st"> </span><span class="kw">rep</span>(synth[[<span class="dv">3</span>]]<span class="op">$</span>beta, <span class="dv">2</span>)
tm3 &lt;-<span class="st"> </span><span class="kw">system.time</span>(res3 &lt;-<span class="st"> </span><span class="kw"><a href="../reference/mcmcPotts.html">mcmcPotts</a></span>(synth[[<span class="dv">3</span>]]<span class="op">$</span>y,
                      neigh, block, priors, mh, <span class="dv">100</span>, <span class="dv">50</span>))</code></pre></div>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">print</span>(tm3)</code></pre></div>
<pre><code>##    user  system elapsed 
##  32.856   1.729   9.305</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">ts.plot</span>(res3<span class="op">$</span>sum, <span class="dt">xlab=</span><span class="st">"MCMC iterations"</span>, <span class="dt">ylab=</span><span class="kw">expression</span>(<span class="kw">S</span>(z)))
<span class="kw">abline</span>(<span class="dt">h=</span>synth[[<span class="dv">3</span>]]<span class="op">$</span>sum, <span class="dt">col=</span><span class="dv">4</span>, <span class="dt">lty=</span><span class="dv">2</span>)</code></pre></div>
<p><img src="mcmcPotts_files/figure-html/unnamed-chunk-7-1.png" width="672"></p>
<p>So far, so good. Now let’s try with <span class="math inline">\(\beta=1.32\)</span>:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">priors<span class="op">$</span>beta &lt;-<span class="st"> </span><span class="kw">rep</span>(synth[[<span class="dv">4</span>]]<span class="op">$</span>beta, <span class="dv">2</span>)
tm4 &lt;-<span class="st"> </span><span class="kw">system.time</span>(res4 &lt;-<span class="st"> </span><span class="kw"><a href="../reference/mcmcPotts.html">mcmcPotts</a></span>(synth[[<span class="dv">4</span>]]<span class="op">$</span>y,
                    neigh, block, priors, mh, <span class="dv">300</span>, <span class="dv">150</span>))</code></pre></div>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">print</span>(tm4)</code></pre></div>
<pre><code>##    user  system elapsed 
## 100.193   4.337  27.559</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">ts.plot</span>(res4<span class="op">$</span>sum, <span class="dt">xlab=</span><span class="st">"MCMC iterations"</span>, <span class="dt">ylab=</span><span class="kw">expression</span>(<span class="kw">S</span>(z)))
<span class="kw">abline</span>(<span class="dt">h=</span>synth[[<span class="dv">4</span>]]<span class="op">$</span>sum, <span class="dt">col=</span><span class="dv">4</span>, <span class="dt">lty=</span><span class="dv">2</span>)</code></pre></div>
<p><img src="mcmcPotts_files/figure-html/unnamed-chunk-9-1.png" width="672"></p>
<p>This doesn’t really count as slow mixing, since the Gibbs sampler has converged within 100 iterations for a lattice with <span class="math inline">\(500 \times 500\)</span> pixels. Compare how long it takes without the external field:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">system.time</span>(res5 &lt;-<span class="st"> </span><span class="kw"><a href="../reference/mcmcPottsNoData.html">mcmcPottsNoData</a></span>(synth[[<span class="dv">4</span>]]<span class="op">$</span>beta, q,
                                    neigh, block, <span class="dv">5000</span>))</code></pre></div>
<pre><code>##    user  system elapsed 
## 263.072   6.611  72.588</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">ts.plot</span>(res5<span class="op">$</span>sum, <span class="dt">xlab=</span><span class="st">"MCMC iterations"</span>, <span class="dt">ylab=</span><span class="kw">expression</span>(<span class="kw">S</span>(z)))
<span class="kw">abline</span>(<span class="dt">h=</span>synth[[<span class="dv">4</span>]]<span class="op">$</span>sum, <span class="dt">col=</span><span class="dv">4</span>, <span class="dt">lty=</span><span class="dv">2</span>)</code></pre></div>
<p><img src="mcmcPotts_files/figure-html/unnamed-chunk-10-1.png" width="672"></p>
<p>This explains why single-site Gibbs sampling should <strong>never</strong> be used for the auxiliary iterations in ABC or the exchange algorithm, but it is usually fine to use when updating the hidden labels. Note that all of these results have been for a fixed <span class="math inline">\(\beta\)</span>. It is more difficult to assess convergence when <span class="math inline">\(\beta\)</span> is unknown. A topic for a future post!</p>
</div>
  </div>

  <div class="col-md-3 hidden-xs hidden-sm" id="sidebar">
      </div>

</div>


      <footer><div class="copyright">
  <p>Developed by Matt Moores, Kerrie Mengersen.</p>
</div>

<div class="pkgdown">
  <p>Site built with <a href="http://hadley.github.io/pkgdown/">pkgdown</a>.</p>
</div>

      </footer>
</div>

  </body>
</html>
